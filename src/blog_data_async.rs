use crate::blog_error::{BlogError, Result};
use im::Vector;
use rusqlite::Connection;
use serde::{Deserialize, Serialize};
use std::path::Path;

/// Represents a blog post tag
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq)]
pub struct Tag {
    pub id: Option<i64>,
    pub name: String,
    pub slug: String,
}

/// Represents a blog post with immutable data
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct BlogPost {
    pub id: Option<i64>,
    pub title: String,
    pub slug: String,
    pub date: String,
    pub author: String,
    pub excerpt: String,
    pub content: String,
    pub published: bool,
    pub featured: bool,
    pub image: Option<String>,
    pub tags: Vector<Tag>,
    pub metadata: im::HashMap<String, String>,
}

#[allow(dead_code)]
impl BlogPost {
    /// Creates a new empty blog post with default values
    pub fn new() -> Self {
        Self {
            id: None,
            title: String::new(),
            slug: String::new(),
            date: chrono::Local::now().format("%Y-%m-%d").to_string(),
            author: String::new(),
            excerpt: String::new(),
            content: String::new(),
            published: false,
            featured: false,
            image: None,
            tags: Vector::new(),
            metadata: im::HashMap::new(),
        }
    }

    /// Generates a slug from the title
    pub fn generate_slug_from_title(&self) -> String {
        self.title
            .to_lowercase()
            .chars()
            .map(|c| if c.is_alphanumeric() { c } else { '-' })
            .collect::<String>()
            .split_whitespace()
            .collect::<Vec<&str>>()
            .join("-")
    }

    /// Creates a new blog post with the specified title and autogenerated slug
    pub fn with_title(title: &str) -> Self {
        let title_str = title.to_string();
        let post = Self {
            title: title_str,
            ..Self::new()
        };
        Self {
            slug: post.generate_slug_from_title(),
            ..post
        }
    }

    /// Returns a new blog post with updated title and slug
    pub fn with_updated_title(self, title: &str) -> Self {
        let post = Self {
            title: title.to_string(),
            ..self
        };
        Self {
            slug: post.generate_slug_from_title(),
            ..post
        }
    }

    /// Returns a new blog post with updated content
    pub fn with_updated_content(self, content: &str) -> Self {
        Self {
            content: content.to_string(),
            ..self
        }
    }

    /// Returns a new blog post with updated excerpt
    pub fn with_updated_excerpt(self, excerpt: &str) -> Self {
        Self {
            excerpt: excerpt.to_string(),
            ..self
        }
    }

    /// Returns a new blog post with updated date
    pub fn with_updated_date(self, date: &str) -> Self {
        Self {
            date: date.to_string(),
            ..self
        }
    }

    /// Returns a new blog post with updated author
    pub fn with_updated_author(self, author: &str) -> Self {
        Self {
            author: author.to_string(),
            ..self
        }
    }

    /// Returns a new blog post with updated image
    pub fn with_updated_image(self, image: Option<String>) -> Self {
        Self { image, ..self }
    }

    /// Returns a new blog post with updated published state
    pub fn with_updated_published(self, published: bool) -> Self {
        Self { published, ..self }
    }

    /// Returns a new blog post with updated featured state
    pub fn with_updated_featured(self, featured: bool) -> Self {
        Self { featured, ..self }
    }

    /// Returns a new blog post with updated tags
    pub fn with_updated_tags(self, tags: Vector<Tag>) -> Self {
        Self { tags, ..self }
    }

    /// Returns a new blog post with updated metadata
    pub fn with_updated_metadata(self, metadata: im::HashMap<String, String>) -> Self {
        Self { metadata, ..self }
    }

    /// Returns a new blog post with added tag
    pub fn with_added_tag(self, tag: Tag) -> Self {
        // Create a new vector with the tag added
        let mut new_tags = self.tags.clone();
        new_tags.push_back(tag);
        Self {
            tags: new_tags,
            ..self
        }
    }

    /// Returns a new blog post with removed tag
    pub fn with_removed_tag(self, tag_name: &str) -> Self {
        Self {
            tags: self
                .tags
                .into_iter()
                .filter(|tag| tag.name != tag_name)
                .collect(),
            ..self
        }
    }

    /// Returns a new blog post with added metadata
    pub fn with_added_metadata(self, key: &str, value: &str) -> Self {
        Self {
            metadata: self.metadata.update(key.to_string(), value.to_string()),
            ..self
        }
    }

    /// Returns a new blog post with removed metadata
    pub fn with_removed_metadata(self, key: &str) -> Self {
        let new_metadata = self.metadata.without(key);
        Self {
            metadata: new_metadata,
            ..self
        }
    }
}

impl Default for BlogPost {
    fn default() -> Self {
        Self::new()
    }
}

/// Manages blog posts using a repository pattern
use crate::blog_converters;
use crate::db::{BlogRepository, Database};

pub struct BlogManager {
    repository: BlogRepository,
}

#[allow(dead_code)]
impl BlogManager {
    /// Creates a new BlogManager with the given SQLite database path
    pub async fn new(db_path: &Path) -> Result<Self> {
        // Create a database instance
        let db = Database::new(db_path)?;
        
        // Get a repository from the database
        let repository = db.blog_repository();
        
        Ok(Self {
            repository,
        })
    }

    /// Initializes the database with required tables
    async fn initialize_db(conn: &Connection) -> Result<()> {
        conn.execute(
            "CREATE TABLE IF NOT EXISTS blog_posts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                slug TEXT NOT NULL UNIQUE,
                date TEXT NOT NULL,
                author TEXT NOT NULL,
                excerpt TEXT NOT NULL,
                content TEXT NOT NULL,
                published BOOLEAN NOT NULL,
                featured BOOLEAN NOT NULL,
                image TEXT
            )",
            [],
        )?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS tags (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                slug TEXT NOT NULL UNIQUE
            )",
            [],
        )?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS post_tags (
                post_id INTEGER NOT NULL,
                tag_id INTEGER NOT NULL,
                PRIMARY KEY (post_id, tag_id),
                FOREIGN KEY (post_id) REFERENCES blog_posts(id) ON DELETE CASCADE,
                FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
            )",
            [],
        )?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS post_metadata (
                post_id INTEGER NOT NULL,
                key TEXT NOT NULL,
                value TEXT NOT NULL,
                PRIMARY KEY (post_id, key),
                FOREIGN KEY (post_id) REFERENCES blog_posts(id) ON DELETE CASCADE
            )",
            [],
        )?;

        Ok(())
    }

    /// Gets all blog posts
    pub async fn get_all_posts(&self) -> Result<Vector<BlogPost>> {
        // Directly await the repository operation
        let repo_posts = self.repository.get_all_posts()
            .await
            .map_err(|e| BlogError::Internal(format!("Failed to get posts: {e}")))?;

        // Convert repository posts to blog_data posts
        let posts = blog_converters::convert_posts_to_data(&repo_posts);

        Ok(posts)
    }

    /// Gets a blog post by ID
    pub async fn get_post_by_id(&self, post_id: i64) -> Result<Option<BlogPost>> {
        // Directly await the repository operation
        let repo_post = self.repository.get_post_by_id(post_id)
            .await
            .map_err(|e| {
                BlogError::Internal(format!("Failed to get post by ID {post_id}: {e}"))
            })?;

        // Convert repository post to blog_data post if found
        Ok(repo_post.map(|post| blog_converters::repo_to_data(&post)))
    }

    /// Gets a blog post by slug
    pub async fn get_post_by_slug(&self, slug: &str) -> Result<Option<BlogPost>> {
        // Directly await the repository operation
        let repo_post = self.repository.get_post_by_slug(slug)
            .await
            .map_err(|e| {
                BlogError::Internal(format!("Failed to get post by slug '{slug}': {e}"))
            })?;

        // Convert repository post to blog_data post if found
        Ok(repo_post.map(|post| blog_converters::repo_to_data(&post)))
    }

    /// Gets all tags
    pub async fn get_all_tags(&self) -> Result<Vector<Tag>> {
        // Directly await the repository operation
        let repo_tags = self.repository.get_all_tags()
            .await
            .map_err(|e| BlogError::Internal(format!("Failed to get all tags: {e}")))?;

        // Convert repository tags to blog_data tags
        let tags = blog_converters::convert_tags_to_data(&repo_tags);

        Ok(tags)
    }

    /// Creates or updates a blog post
    pub async fn create_or_update_post(&self, post: &BlogPost) -> Result<i64> {
        println!("Starting create_or_update_post operation...");

        // Convert blog_data post to repository post
        let repo_post = blog_converters::data_to_repo(post);

        // Directly await the repository operation
        let post_id = self.repository.create_or_update_post(&repo_post)
            .await
            .map_err(|e| BlogError::Internal(format!("Failed to create or update post: {e}")))?;

        println!("Post operation completed with ID: {post_id}");
        Ok(post_id)
    }

    /// Deletes a blog post
    pub async fn delete_post(&self, post_id: i64) -> Result<()> {
        // Directly await the repository operation
        self.repository.delete_post(post_id)
            .await
            .map_err(|e| {
                BlogError::Internal(format!("Failed to delete post with ID {post_id}: {e}"))
            })?;

        println!("Post with ID {post_id} deleted successfully");
        Ok(())
    }

    /// Gets all published blog posts
    pub async fn get_published_posts(&self) -> Result<Vector<BlogPost>> {
        // Directly await the repository operation
        let repo_posts = self.repository.get_published_posts()
            .await
            .map_err(|e| BlogError::Internal(format!("Failed to get published posts: {e}")))?;

        // Convert repository posts to blog_data posts
        let posts = blog_converters::convert_posts_to_data(&repo_posts);

        Ok(posts)
    }

    /// Gets all featured blog posts
    pub async fn get_featured_posts(&self) -> Result<Vector<BlogPost>> {
        // Directly await the repository operation
        let repo_posts = self.repository.get_featured_posts()
            .await
            .map_err(|e| BlogError::Internal(format!("Failed to get featured posts: {e}")))?;

        // Convert repository posts to blog_data posts
        let posts = blog_converters::convert_posts_to_data(&repo_posts);

        Ok(posts)
    }

    /// Gets posts by tag
    pub async fn get_posts_by_tag(&self, tag_slug: &str) -> Result<Vector<BlogPost>> {
        // Directly await the repository operation
        let repo_posts = self.repository.get_posts_by_tag(tag_slug)
            .await
            .map_err(|e| {
                BlogError::Internal(format!("Failed to get posts by tag '{tag_slug}': {e}"))
            })?;

        // Convert repository posts to blog_data posts
        let posts = blog_converters::convert_posts_to_data(&repo_posts);

        Ok(posts)
    }
}