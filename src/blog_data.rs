use crate::blog_error::{BlogError, Result};
use im::Vector;
use rusqlite::Connection;
use serde::{Deserialize, Serialize};
use std::path::Path;
use utoipa::ToSchema;

/// Represents a blog post tag
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq, Eq, ToSchema)]
#[schema(description = "A tag for categorizing blog posts")]
pub struct Tag {
    /// Unique identifier for the tag (null for new tags)
    #[schema(example = 1)]
    pub id: Option<i64>,
    
    /// Display name of the tag
    #[schema(example = "Technology")]
    pub name: String,
    
    /// URL-friendly version of the name
    #[schema(example = "technology")]
    pub slug: String,
}

/// Represents a blog post with immutable data
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct BlogPost {
    pub id: Option<i64>,
    pub title: String,
    pub slug: String,
    pub date: String,
    pub author: String,
    pub excerpt: String,
    pub content: String,
    pub published: bool,
    pub featured: bool,
    pub image: Option<String>,
    pub tags: Vector<Tag>,
    pub metadata: im::HashMap<String, String>,
}

#[allow(dead_code)]
impl BlogPost {
    /// Creates a new empty blog post with default values
    pub fn new() -> Self {
        Self {
            id: None,
            title: String::new(),
            slug: String::new(),
            date: chrono::Local::now().format("%Y-%m-%d").to_string(),
            author: String::new(),
            excerpt: String::new(),
            content: String::new(),
            published: false,
            featured: false,
            image: None,
            tags: Vector::new(),
            metadata: im::HashMap::new(),
        }
    }

    /// Generates a slug from the title
    pub fn generate_slug_from_title(&self) -> String {
        self.title
            .to_lowercase()
            .chars()
            .map(|c| if c.is_alphanumeric() { c } else { '-' })
            .collect::<String>()
            .split_whitespace()
            .collect::<Vec<&str>>()
            .join("-")
    }

    /// Creates a new blog post with the specified title and autogenerated slug
    pub fn with_title(title: &str) -> Self {
        let title_str = title.to_string();
        let post = Self {
            title: title_str,
            ..Self::new()
        };
        Self {
            slug: post.generate_slug_from_title(),
            ..post
        }
    }

    /// Returns a new blog post with updated title and slug
    pub fn with_updated_title(self, title: &str) -> Self {
        let post = Self {
            title: title.to_string(),
            ..self
        };
        Self {
            slug: post.generate_slug_from_title(),
            ..post
        }
    }

    /// Returns a new blog post with updated content
    pub fn with_updated_content(self, content: &str) -> Self {
        Self {
            content: content.to_string(),
            ..self
        }
    }

    /// Returns a new blog post with updated excerpt
    pub fn with_updated_excerpt(self, excerpt: &str) -> Self {
        Self {
            excerpt: excerpt.to_string(),
            ..self
        }
    }

    /// Returns a new blog post with updated date
    pub fn with_updated_date(self, date: &str) -> Self {
        Self {
            date: date.to_string(),
            ..self
        }
    }

    /// Returns a new blog post with updated author
    pub fn with_updated_author(self, author: &str) -> Self {
        Self {
            author: author.to_string(),
            ..self
        }
    }

    /// Returns a new blog post with updated image
    pub fn with_updated_image(self, image: Option<String>) -> Self {
        Self { image, ..self }
    }

    /// Returns a new blog post with updated published state
    pub fn with_updated_published(self, published: bool) -> Self {
        Self { published, ..self }
    }

    /// Returns a new blog post with updated featured state
    pub fn with_updated_featured(self, featured: bool) -> Self {
        Self { featured, ..self }
    }

    /// Returns a new blog post with updated tags
    pub fn with_updated_tags(self, tags: Vector<Tag>) -> Self {
        Self { tags, ..self }
    }

    /// Returns a new blog post with updated metadata
    pub fn with_updated_metadata(self, metadata: im::HashMap<String, String>) -> Self {
        Self { metadata, ..self }
    }

    /// Returns a new blog post with added tag
    pub fn with_added_tag(self, tag: Tag) -> Self {
        // Create a new vector with the tag added
        let mut new_tags = self.tags.clone();
        new_tags.push_back(tag);
        Self {
            tags: new_tags,
            ..self
        }
    }

    /// Returns a new blog post with removed tag
    pub fn with_removed_tag(self, tag_name: &str) -> Self {
        Self {
            tags: self
                .tags
                .into_iter()
                .filter(|tag| tag.name != tag_name)
                .collect(),
            ..self
        }
    }

    /// Returns a new blog post with added metadata
    pub fn with_added_metadata(self, key: &str, value: &str) -> Self {
        Self {
            metadata: self.metadata.update(key.to_string(), value.to_string()),
            ..self
        }
    }

    /// Returns a new blog post with removed metadata
    pub fn with_removed_metadata(self, key: &str) -> Self {
        let new_metadata = self.metadata.without(key);
        Self {
            metadata: new_metadata,
            ..self
        }
    }
}

impl Default for BlogPost {
    fn default() -> Self {
        Self::new()
    }
}

/// Manages blog posts using a repository pattern
use crate::blog_converters;
use crate::db::{BlogRepository, Database};
use tokio::runtime::Runtime;

pub struct BlogManager {
    repository: BlogRepository,
    runtime: Runtime,
}

#[allow(dead_code)]
impl BlogManager {
    /// Creates a new BlogManager with the given SQLite database path
    pub fn new(db_path: &Path) -> Result<Self> {
        // Create a database instance
        let db = Database::new(db_path)?;

        // Get a repository from the database
        let repository = db.blog_repository();

        // Create a runtime for executing async code in a synchronous context
        let runtime = Runtime::new()
            .map_err(|e| BlogError::Internal(format!("Failed to create runtime: {e}")))?;

        Ok(Self {
            repository,
            runtime,
        })
    }

    /// Initializes the database with required tables
    fn initialize_db(conn: &Connection) -> Result<()> {
        conn.execute(
            "CREATE TABLE IF NOT EXISTS blog_posts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                title TEXT NOT NULL,
                slug TEXT NOT NULL UNIQUE,
                date TEXT NOT NULL,
                author TEXT NOT NULL,
                excerpt TEXT NOT NULL,
                content TEXT NOT NULL,
                published BOOLEAN NOT NULL,
                featured BOOLEAN NOT NULL,
                image TEXT
            )",
            [],
        )?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS tags (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                slug TEXT NOT NULL UNIQUE
            )",
            [],
        )?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS post_tags (
                post_id INTEGER NOT NULL,
                tag_id INTEGER NOT NULL,
                PRIMARY KEY (post_id, tag_id),
                FOREIGN KEY (post_id) REFERENCES blog_posts(id) ON DELETE CASCADE,
                FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
            )",
            [],
        )?;

        conn.execute(
            "CREATE TABLE IF NOT EXISTS post_metadata (
                post_id INTEGER NOT NULL,
                key TEXT NOT NULL,
                value TEXT NOT NULL,
                PRIMARY KEY (post_id, key),
                FOREIGN KEY (post_id) REFERENCES blog_posts(id) ON DELETE CASCADE
            )",
            [],
        )?;

        Ok(())
    }

    /// Gets all blog posts
    pub fn get_all_posts(&self) -> Result<Vector<BlogPost>> {
        // Use the runtime to execute the async method synchronously
        let repo_posts = self
            .runtime
            .block_on(self.repository.get_all_posts())
            .map_err(|e| BlogError::Internal(format!("Failed to get posts: {e}")))?;

        // Convert repository posts to blog_data posts
        let posts = blog_converters::convert_posts_to_data(&repo_posts);

        Ok(posts)
    }

    /// Gets a blog post by ID
    pub fn get_post_by_id(&self, post_id: i64) -> Result<Option<BlogPost>> {
        // Use the runtime to execute the async method synchronously
        let repo_post = self
            .runtime
            .block_on(self.repository.get_post_by_id(post_id))
            .map_err(|e| BlogError::Internal(format!("Failed to get post by ID {post_id}: {e}")))?;

        // Convert repository post to blog_data post if found
        Ok(repo_post.map(|post| blog_converters::repo_to_data(&post)))
    }

    pub fn get_post_by_slug(&self, slug: &str) -> Result<Option<BlogPost>> {
        // Use the runtime to execute the async method synchronously
        let repo_post = self
            .runtime
            .block_on(self.repository.get_post_by_slug(slug))
            .map_err(|e| {
                BlogError::Internal(format!("Failed to get post by slug '{slug}': {e}"))
            })?;

        // Convert repository post to blog_data post if found
        Ok(repo_post.map(|post| blog_converters::repo_to_data(&post)))
    }

    /// Gets all tags
    pub fn get_all_tags(&self) -> Result<Vector<Tag>> {
        // Use the runtime to execute the async method synchronously
        let repo_tags = self
            .runtime
            .block_on(self.repository.get_all_tags())
            .map_err(|e| BlogError::Internal(format!("Failed to get all tags: {e}")))?;

        // Convert repository tags to blog_data tags
        let tags = blog_converters::convert_tags_to_data(&repo_tags);

        Ok(tags)
    }

    /// Creates or updates a blog post
    pub fn create_or_update_post(&self, post: &BlogPost) -> Result<i64> {
        println!("Starting create_or_update_post operation...");

        // Convert blog_data post to repository post
        let repo_post = blog_converters::data_to_repo(post);

        // Use the runtime to execute the async method synchronously
        let post_id = self
            .runtime
            .block_on(self.repository.create_or_update_post(&repo_post))
            .map_err(|e| BlogError::Internal(format!("Failed to create or update post: {e}")))?;

        println!("Post operation completed with ID: {post_id}");
        Ok(post_id)
    }

    /// Deletes a blog post
    pub fn delete_post(&self, post_id: i64) -> Result<()> {
        // Use the runtime to execute the async method synchronously
        self.runtime
            .block_on(self.repository.delete_post(post_id))
            .map_err(|e| {
                BlogError::Internal(format!("Failed to delete post with ID {post_id}: {e}"))
            })?;

        println!("Post with ID {post_id} deleted successfully");
        Ok(())
    }

    /// Gets all published blog posts
    pub fn get_published_posts(&self) -> Result<Vector<BlogPost>> {
        // Use the runtime to execute the async method synchronously
        let repo_posts = self
            .runtime
            .block_on(self.repository.get_published_posts())
            .map_err(|e| BlogError::Internal(format!("Failed to get published posts: {e}")))?;

        // Convert repository posts to blog_data posts
        let posts = blog_converters::convert_posts_to_data(&repo_posts);

        Ok(posts)
    }

    /// Gets all featured blog posts
    pub fn get_featured_posts(&self) -> Result<Vector<BlogPost>> {
        // Use the runtime to execute the async method synchronously
        let repo_posts = self
            .runtime
            .block_on(self.repository.get_featured_posts())
            .map_err(|e| BlogError::Internal(format!("Failed to get featured posts: {e}")))?;

        // Convert repository posts to blog_data posts
        let posts = blog_converters::convert_posts_to_data(&repo_posts);

        Ok(posts)
    }

    /// Gets posts by tag
    pub fn get_posts_by_tag(&self, tag_slug: &str) -> Result<Vector<BlogPost>> {
        // Use the runtime to execute the async method synchronously
        let repo_posts = self
            .runtime
            .block_on(self.repository.get_posts_by_tag(tag_slug))
            .map_err(|e| {
                BlogError::Internal(format!("Failed to get posts by tag '{tag_slug}': {e}"))
            })?;

        // Convert repository posts to blog_data posts
        let posts = blog_converters::convert_posts_to_data(&repo_posts);

        Ok(posts)
    }
}
