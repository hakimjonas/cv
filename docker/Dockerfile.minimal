# Ultra-minimal production Dockerfile using multi-stage build with distroless final image
# Stage 1: Builder (same as Dockerfile.prod but with additional optimizations)
FROM rust:1.88.0-alpine3.20 as builder

# Set up build environment
WORKDIR /usr/src/app

# Install build dependencies with retry logic for better network resilience
RUN apk add --no-cache --virtual .build-deps \
    build-base \
    pkgconfig \
    openssl-dev \
    git \
    curl \
    musl-dev \
    && echo "Build dependencies installed successfully"

# Configure multiple DNS servers for better network resilience
RUN echo "nameserver 1.1.1.1" > /etc/resolv.conf \
    && echo "nameserver 8.8.8.8" >> /etc/resolv.conf \
    && echo "nameserver 9.9.9.9" >> /etc/resolv.conf \
    && echo "options timeout:2 attempts:3 rotate" >> /etc/resolv.conf

# Configure Cargo for better network resilience
RUN mkdir -p ~/.cargo \
    && echo '[net]' > ~/.cargo/config.toml \
    && echo 'retry = 3' >> ~/.cargo/config.toml \
    && echo 'connect-timeout = 30' >> ~/.cargo/config.toml \
    && echo 'git-fetch-with-cli = true' >> ~/.cargo/config.toml \
    && echo '[source.crates-io]' >> ~/.cargo/config.toml \
    && echo 'registry = "https://github.com/rust-lang/crates.io-index"' >> ~/.cargo/config.toml \
    && echo 'replace-with = "ustc"' >> ~/.cargo/config.toml \
    && echo '[source.ustc]' >> ~/.cargo/config.toml \
    && echo 'registry = "sparse+https://mirrors.ustc.edu.cn/crates.io-index/"' >> ~/.cargo/config.toml \
    && echo '[http]' >> ~/.cargo/config.toml \
    && echo 'timeout = 30' >> ~/.cargo/config.toml \
    && echo 'low-speed-limit = 5' >> ~/.cargo/config.toml \
    && echo 'multiplexing = false' >> ~/.cargo/config.toml \
    && echo 'check-revoke = false' >> ~/.cargo/config.toml

# Build for musl target to create a static binary
RUN rustup target add x86_64-unknown-linux-musl

# Copy only the dependency files first for better caching
COPY Cargo.toml Cargo.lock ./

# Create a dummy main.rs to build dependencies
RUN mkdir -p src && \
    echo "fn main() {}" > src/main.rs && \
    # Build with retry logic for better network resilience
    for i in $(seq 1 3); do \
        echo "Attempt $i: Building dependencies..." && \
        (cargo build --release --target x86_64-unknown-linux-musl && break || { echo "Attempt $i failed, retrying..."; sleep 15; }) \
    done && \
    rm -rf src && \
    rm -rf target/x86_64-unknown-linux-musl/release/.fingerprint/cv-*

# Copy the actual source code
COPY src ./src/
COPY static ./static/
COPY templates ./templates/
COPY data ./data/

# Generate the website files first with retry logic
RUN for i in $(seq 1 3); do \
        echo "Attempt $i: Generating website files..." && \
        (cargo run --bin cv && break || { echo "Attempt $i failed, retrying..."; sleep 15; }) \
    done

# Build the application with retry logic as a static binary
RUN for i in $(seq 1 3); do \
        echo "Attempt $i: Building application..." && \
        (RUSTFLAGS="-C target-feature=+crt-static" cargo build --release --target x86_64-unknown-linux-musl --bin blog_api_server && break || { echo "Attempt $i failed, retrying..."; sleep 15; }) \
    done

# Verify the binary exists and is statically linked
RUN ls -la target/x86_64-unknown-linux-musl/release/blog_api_server || { echo "Binary not found!"; exit 1; } && \
    ldd target/x86_64-unknown-linux-musl/release/blog_api_server || echo "Binary is statically linked"

# Optimize the binary size
RUN strip target/x86_64-unknown-linux-musl/release/blog_api_server

# Stage 2: Create a minimal runtime image using distroless
FROM gcr.io/distroless/static-debian12:nonroot

# Copy the binary from the builder stage
COPY --from=builder /usr/src/app/target/x86_64-unknown-linux-musl/release/blog_api_server /app/blog_api_server

# Copy only the necessary static assets and generated website files
COPY --from=builder /usr/src/app/dist /app/dist
COPY --from=builder /usr/src/app/static /app/static
COPY --from=builder /usr/src/app/templates /app/templates

# Create a directory for data (will be mounted as a volume)
WORKDIR /app

# Set environment variables
ENV RUST_LOG=info

# Expose the port
EXPOSE 3000

# Health check (using wget since curl is not available in distroless)
HEALTHCHECK --interval=30s --timeout=5s --start-period=5s --retries=3 \
  CMD ["/app/blog_api_server", "--health-check"] || exit 1

# Run the binary
CMD ["/app/blog_api_server"]