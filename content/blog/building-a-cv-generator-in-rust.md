---
title: "On Building a CV Generator: Immutability as Architecture"
date: 2024-12-17
published: true
tags: ["rust", "functional-programming", "static-site-generator", "typst"]
---

This site is generated by a tool I wrote in Rust. The decision to build rather than use an existing solution was partly practical, partly intellectual curiosity about applying functional programming patterns to a systems language.

## The Problem Statement

CV generators tend toward two failure modes. The simple ones produce generic output indistinguishable from a thousand others. The sophisticated ones require ongoing maintenance that exceeds the effort of manually updating a document. I wanted something between these extremes: a generator that could produce both HTML and PDF from a single data source, integrate with GitHub for project data, and require zero maintenance after initial configuration.

The additional constraint was that content updates—fixing a typo, adding a new position—should not require any code changes. This led to the two-branch architecture where the `main` branch contains only application code, and content lives on a separate `content` branch.

## Immutability as a Design Principle

The project uses the [`im`](https://docs.rs/im) crate throughout for persistent data structures:

```rust
use im::{Vector, HashMap};

pub struct Cv {
    pub personal_info: PersonalInfo,
    pub experiences: Vector<Experience>,
    pub education: Vector<Education>,
    pub projects: Vector<Project>,
    pub languages: HashMap<String, String>,
}
```

These are not merely immutable wrappers around standard collections. The `im` crate implements persistent data structures with structural sharing—when you create a modified version of a `Vector`, unchanged portions are shared between the old and new versions. This gives you immutability without the naive O(n) copy on every operation.

The practical consequence is that the entire generation pipeline becomes a series of transformations. Data flows in one direction. Functions take arguments and return values. There is no hidden state to track, no temporal coupling between operations. When something goes wrong, the bug is localized to whichever transformation produced incorrect output.

This approach trades mutation for explicitness. Whether that trade-off makes sense depends on the problem domain. For a build pipeline that runs once and produces output, the benefits are clear. For a long-running application with complex state transitions, the calculus might be different.

## Functional Composition Without a Pipe Operator

Rust lacks the pipe operators found in F#, Elixir, or the Unix shell. The conventional approach is method chaining, which works well when you control the types. For functions that take ownership of their arguments and return new values, a simple trait fills the gap:

```rust
trait Pipe: Sized {
    fn pipe<F, R>(self, f: F) -> R
    where
        F: FnOnce(Self) -> R,
    {
        f(self)
    }
}
```

The Typst generator uses this to build the document through successive transformations:

```rust
String::new()
    .pipe(|s| append_markup(s, &generate_imports(config)))
    .pipe(|s| append_markup(s, &generate_layout_settings(config)))
    .pipe(|s| append_markup(s, &generate_personal_info(cv)))
    .pipe(|s| append_markup(s, &generate_left_pane(cv)))
    .pipe(|s| append_markup(s, &generate_right_pane(cv)))
```

Each step is a pure function. The pipeline reads top-to-bottom, and adding or removing a stage is a matter of adding or removing a line. This is not novel—it is how data pipelines have worked in functional languages for decades—but it transfers cleanly to Rust.

## The Caching Problem

The generator fetches project data from the GitHub API. Without caching, this adds roughly two seconds to every build. The temptation is to cache aggressively, but caching introduces its own complexity: cache invalidation, TTL management, cache corruption handling.

The solution was a TTL-based cache with explicit expiration:

```rust
pub struct GitHubCacheEntry<T> {
    pub data: T,
    pub cached_at: DateTime<Utc>,
    pub ttl_minutes: u32,
}
```

Projects cache for one hour; avatars for four. The rationale: project metadata changes occasionally (new commits, stars), but rarely in ways that affect the CV. Avatar URLs essentially never change. Different data, different TTLs.

The cache reduced build time from 2,266ms to 524ms—a 77% improvement. More importantly, cached builds make zero network requests, which matters when iterating on templates or debugging CSS.

## Authentication Fallbacks

GitHub authentication is handled through a priority chain:

1. `GITHUB_TOKEN` environment variable (GitHub Actions provides this automatically)
2. `GH_TOKEN` environment variable (common convention for user tokens)
3. Output from `gh auth token` (if the GitHub CLI is installed and authenticated)
4. Public API with no authentication (60 requests per hour)

This means the generator works without configuration on GitHub Actions, works locally if you have `gh` installed, and gracefully degrades to the public API otherwise. The code tries each option in sequence, stopping at the first success. There is no "setup GitHub authentication" step in the documentation because there does not need to be one.

## Color Schemes as Data

The site's color scheme is not hardcoded in CSS. Instead, it is fetched at build time from a color scheme provider:

```rust
trait ColorSchemeProvider {
    fn fetch(&self, name: &str, variant: Option<&str>) -> Result<ColorPalette>;
}
```

The default provider fetches from the [iTerm2-Color-Schemes](https://github.com/mbadolato/iTerm2-Color-Schemes) repository, which contains over 200 terminal color schemes in a machine-readable format. Configuration is a matter of specifying which scheme to use:

```json
{
  "colorscheme": {
    "name": "Rose Pine Moon",
    "source": "iterm2"
  }
}
```

The fetched palette is converted to CSS custom properties. The same palette drives the PDF generation through Typst. This means the HTML and PDF outputs share a color scheme, and changing it requires modifying a single line in a JSON file.

The provider pattern makes it straightforward to add new sources. Ghostty and Base16 schemes required only implementing the trait for their respective formats.

## PDF Generation with Typst

[Typst](https://typst.app/) is a modern typesetting system positioned as a LaTeX alternative. It compiles faster, has a more approachable syntax, and produces comparable output. For a CV, where the document structure is simple but visual polish matters, it is well-suited.

The generator produces a `.typ` file from templates, then invokes the Typst CLI:

```rust
Command::new("typst")
    .args(["compile", &temp_path, &output_path])
    .output()?;
```

PDF generation accounts for roughly 60% of total build time. This is acceptable given that it happens once per build, and the output is a professionally typeset document.

## Using the Template

The repository is configured as a GitHub template. Click "Use this template" to create a new repository with the code but without my content branch. Create your own `content` branch, edit `data/cv_data.json` with your information, enable GitHub Pages, and the CI handles the rest.

The separation of code and content means updates to the generator itself can be pulled from upstream without overwriting your data. This was a deliberate architectural decision: the tool should be usable without modification, and modifications should be possible without forking.

## Source

The code is available at [github.com/hakimjonas/cv](https://github.com/hakimjonas/cv). The implementation is roughly 2,500 lines of Rust across a dozen modules. It is not a framework or a library—it is a single-purpose tool that does one thing adequately.
