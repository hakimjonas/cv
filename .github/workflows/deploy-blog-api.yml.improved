name: Deploy Blog API

on:
  push:
    branches: [ main ]
    paths:
      - 'src/**'
      - 'Cargo.toml'
      - 'Cargo.lock'
      - 'Dockerfile*'
      - 'docker-compose*.yml'
      - '.github/workflows/deploy-blog-api.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      version:
        description: 'Version to deploy (leave empty for auto-generated)'
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/blog-api

jobs:
  build:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      version: ${{ steps.version.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Fetch all history for proper versioning
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Generate version
        id: version
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            VERSION="${{ github.event.inputs.version }}"
          else
            VERSION=$(date +'%Y%m%d')-$(git rev-parse --short HEAD)
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v4
        with:
          context: .
          file: ./Dockerfile.improved
          push: true
          build-args: |
            BUILD_VERSION=${{ steps.version.outputs.version }}
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.version }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build
    if: ${{ github.event.inputs.environment == 'staging' || github.event.inputs.environment == '' }}
    environment:
      name: staging
      url: https://staging-api.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.STAGING_SSH_PRIVATE_KEY }}
      
      - name: Add known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.STAGING_SERVER_IP }} >> ~/.ssh/known_hosts
      
      - name: Create deployment directory
        run: |
          ssh ${{ secrets.STAGING_SERVER_USER }}@${{ secrets.STAGING_SERVER_IP }} "mkdir -p ~/blog-api-deployments/${{ needs.build.outputs.version }}"
      
      - name: Copy deployment files
        run: |
          scp docker-compose.prod.yml ${{ secrets.STAGING_SERVER_USER }}@${{ secrets.STAGING_SERVER_IP }}:~/blog-api-deployments/${{ needs.build.outputs.version }}/docker-compose.yml
          scp nginx/nginx.conf ${{ secrets.STAGING_SERVER_USER }}@${{ secrets.STAGING_SERVER_IP }}:~/blog-api-deployments/${{ needs.build.outputs.version }}/nginx.conf
      
      - name: Create .env file
        run: |
          cat << EOF > .env
          BUILD_VERSION=${{ needs.build.outputs.version }}
          REGISTRY=${{ env.REGISTRY }}
          IMAGE_NAME=${{ env.IMAGE_NAME }}
          ENVIRONMENT=staging
          EOF
          scp .env ${{ secrets.STAGING_SERVER_USER }}@${{ secrets.STAGING_SERVER_IP }}:~/blog-api-deployments/${{ needs.build.outputs.version }}/.env
      
      - name: Deploy on staging server
        run: |
          ssh ${{ secrets.STAGING_SERVER_USER }}@${{ secrets.STAGING_SERVER_IP }} "cd ~/blog-api-deployments/${{ needs.build.outputs.version }} && \
            docker login ${{ env.REGISTRY }} -u ${{ github.actor }} -p ${{ secrets.GITHUB_TOKEN }} && \
            docker-compose pull && \
            docker-compose up -d && \
            ln -sfn ~/blog-api-deployments/${{ needs.build.outputs.version }} ~/blog-api-current"
      
      - name: Verify deployment
        run: |
          # Wait for the service to start
          sleep 20
          # Check if the service is accessible
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://staging-api.example.com/health || echo "Failed")
          if [ "$HEALTH_STATUS" != "200" ]; then
            echo "Deployment verification failed with status: $HEALTH_STATUS"
            exit 1
          fi
          echo "Deployment verified successfully"
      
      - name: Notify on success
        uses: slackapi/slack-github-action@v1.23.0
        with:
          payload: |
            {
              "text": "✅ Successfully deployed blog-api version ${{ needs.build.outputs.version }} to staging",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "✅ *Successfully deployed blog-api to staging*"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Version:*\n${{ needs.build.outputs.version }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Environment:*\nStaging"
                    }
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Deployment"
                      },
                      "url": "https://staging-api.example.com"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
      
      - name: Cleanup old deployments
        run: |
          ssh ${{ secrets.STAGING_SERVER_USER }}@${{ secrets.STAGING_SERVER_IP }} "ls -1t ~/blog-api-deployments | tail -n +6 | xargs -I {} rm -rf ~/blog-api-deployments/{}"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build, deploy-staging]
    if: ${{ github.event.inputs.environment == 'production' }}
    environment:
      name: production
      url: https://api.example.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_PRIVATE_KEY }}
      
      - name: Add known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.PRODUCTION_SERVER_IP }} >> ~/.ssh/known_hosts
      
      - name: Create deployment directory
        run: |
          ssh ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }} "mkdir -p ~/blog-api-deployments/${{ needs.build.outputs.version }}"
      
      - name: Copy deployment files
        run: |
          scp docker-compose.prod.yml ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }}:~/blog-api-deployments/${{ needs.build.outputs.version }}/docker-compose.yml
          scp nginx/nginx.conf ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }}:~/blog-api-deployments/${{ needs.build.outputs.version }}/nginx.conf
      
      - name: Create .env file
        run: |
          cat << EOF > .env
          BUILD_VERSION=${{ needs.build.outputs.version }}
          REGISTRY=${{ env.REGISTRY }}
          IMAGE_NAME=${{ env.IMAGE_NAME }}
          ENVIRONMENT=production
          EOF
          scp .env ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }}:~/blog-api-deployments/${{ needs.build.outputs.version }}/.env
      
      - name: Backup database before deployment
        run: |
          ssh ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }} "mkdir -p ~/backups && \
            docker exec blog-api sqlite3 /app/data/blog.db .dump > ~/backups/blog-${{ needs.build.outputs.version }}.sql"
      
      - name: Deploy on production server (Blue-Green)
        run: |
          ssh ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }} "cd ~/blog-api-deployments/${{ needs.build.outputs.version }} && \
            docker login ${{ env.REGISTRY }} -u ${{ github.actor }} -p ${{ secrets.GITHUB_TOKEN }} && \
            docker-compose pull && \
            # Start the new version (green)
            docker-compose -p blog-api-green up -d && \
            # Wait for the new version to be healthy
            for i in {1..10}; do \
              if docker ps | grep blog-api-green | grep -q '(healthy)'; then \
                echo 'New version is healthy'; \
                # Update the Nginx config to route traffic to the new version
                sed -i 's/# server blog-api-green/server blog-api-green/' ~/blog-api-current/nginx.conf && \
                sed -i 's/server blog-api-blue/# server blog-api-blue/' ~/blog-api-current/nginx.conf && \
                docker exec nginx nginx -s reload && \
                # If everything is good, update the current symlink
                ln -sfn ~/blog-api-deployments/${{ needs.build.outputs.version }} ~/blog-api-current && \
                # Stop the old version (blue)
                docker-compose -p blog-api-blue down; \
                break; \
              fi; \
              echo 'Waiting for new version to be healthy...'; \
              sleep 10; \
            done"
      
      - name: Verify deployment
        run: |
          # Wait for the service to start
          sleep 20
          # Check if the service is accessible
          HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://api.example.com/health || echo "Failed")
          if [ "$HEALTH_STATUS" != "200" ]; then
            echo "Deployment verification failed with status: $HEALTH_STATUS"
            # Rollback
            ssh ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }} "cd ~/blog-api-current && \
              # Revert Nginx config
              sed -i 's/server blog-api-green/# server blog-api-green/' ~/blog-api-current/nginx.conf && \
              sed -i 's/# server blog-api-blue/server blog-api-blue/' ~/blog-api-current/nginx.conf && \
              docker exec nginx nginx -s reload && \
              # Stop the new version
              docker-compose -p blog-api-green down && \
              # Start the old version if it's not running
              docker-compose -p blog-api-blue up -d"
            exit 1
          fi
          echo "Deployment verified successfully"
      
      - name: Notify on success
        uses: slackapi/slack-github-action@v1.23.0
        with:
          payload: |
            {
              "text": "✅ Successfully deployed blog-api version ${{ needs.build.outputs.version }} to production",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "✅ *Successfully deployed blog-api to production*"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Version:*\n${{ needs.build.outputs.version }}"
                    },
                    {
                      "type": "mrkdwn",
                      "text": "*Environment:*\nProduction"
                    }
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Deployment"
                      },
                      "url": "https://api.example.com"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
      
      - name: Cleanup old deployments
        run: |
          ssh ${{ secrets.PRODUCTION_SERVER_USER }}@${{ secrets.PRODUCTION_SERVER_IP }} "ls -1t ~/blog-api-deployments | tail -n +4 | xargs -I {} rm -rf ~/blog-api-deployments/{}"